--- flask_appbuilder/_compat.py	(original)
+++ flask_appbuilder/_compat.py	(refactored)
@@ -18,9 +18,9 @@
     string_types = (str,)
     integer_types = (int, )
 
-    iterkeys = lambda d: iter(d.keys())
-    itervalues = lambda d: iter(d.values())
-    iteritems = lambda d: iter(d.items())
+    iterkeys = lambda d: iter(list(d.keys()))
+    itervalues = lambda d: iter(list(d.values()))
+    iteritems = lambda d: iter(list(d.items()))
 
     def as_unicode(s):
         if isinstance(s, bytes):
@@ -29,16 +29,16 @@
         return str(s)
 
 else:
-    text_type = unicode
-    string_types = (str, unicode)
-    integer_types = (int, long)
+    text_type = str
+    string_types = (str, str)
+    integer_types = (int, int)
 
-    iterkeys = lambda d: d.iterkeys()
-    itervalues = lambda d: d.itervalues()
-    iteritems = lambda d: d.iteritems()
+    iterkeys = lambda d: iter(d.keys())
+    itervalues = lambda d: iter(d.values())
+    iteritems = lambda d: iter(d.items())
 
     def as_unicode(s):
         if isinstance(s, str):
             return s.decode('utf-8')
 
-        return unicode(s)
+        return str(s)
--- flask_appbuilder/fieldwidgets.py	(original)
+++ flask_appbuilder/fieldwidgets.py	(refactored)
@@ -56,7 +56,7 @@
 
 class BS3TextFieldWidget(widgets.TextInput):
     def __call__(self, field, **kwargs):
-        kwargs['class'] = u'form-control'
+        kwargs['class'] = 'form-control'
         if field.label:
             kwargs['placeholder'] = field.label.text
         if 'name_' in kwargs:
@@ -65,7 +65,7 @@
 
 class BS3TextAreaFieldWidget(widgets.TextArea):
     def __call__(self, field, **kwargs):
-        kwargs['class'] = u'form-control'
+        kwargs['class'] = 'form-control'
         kwargs['rows'] = 3
         if field.label:
             kwargs['placeholder'] = field.label.text
@@ -73,7 +73,7 @@
 
 class BS3PasswordFieldWidget(widgets.PasswordInput):
     def __call__(self, field, **kwargs):
-        kwargs['class'] = u'form-control'
+        kwargs['class'] = 'form-control'
         if field.label:
             kwargs['placeholder'] = field.label.text
         return super(BS3PasswordFieldWidget, self).__call__(field, **kwargs)
@@ -81,19 +81,19 @@
 
 class Select2Widget(widgets.Select):
     def __call__(self, field, **kwargs):
-        kwargs['class'] = u'my_select2'
-        kwargs['style'] = u'width:250px'
-        kwargs['data-placeholder'] = u'Select Value'
+        kwargs['class'] = 'my_select2'
+        kwargs['style'] = 'width:250px'
+        kwargs['data-placeholder'] = 'Select Value'
         if 'name_' in kwargs:
             field.name = kwargs['name_']
         return super(Select2Widget, self).__call__(field, **kwargs)
 
 class Select2ManyWidget(widgets.Select):
     def __call__(self, field, **kwargs):
-        kwargs['class'] = u'my_select2'
-        kwargs['style'] = u'width:250px'
-        kwargs['data-placeholder'] = u'Select Value'
-        kwargs['multiple'] = u'true'
+        kwargs['class'] = 'my_select2'
+        kwargs['style'] = 'width:250px'
+        kwargs['data-placeholder'] = 'Select Value'
+        kwargs['multiple'] = 'true'
         if 'name_' in kwargs:
             field.name = kwargs['name_']
         return super(Select2ManyWidget, self).__call__(field, **kwargs)
--- flask_appbuilder/filters.py	(original)
+++ flask_appbuilder/filters.py	(refactored)
@@ -39,7 +39,7 @@
         else:
             args['_oc_' + generalview_name] = column
             args['_od_' + generalview_name] = 'asc'
-        return url_for(request.endpoint,**dict(new_args.items() + args.to_dict().items()))
+        return url_for(request.endpoint,**dict(list(new_args.items()) + list(args.to_dict().items())))
 
 
     @app_template_filter('link_page')
@@ -50,7 +50,7 @@
         new_args = request.view_args.copy()
         args = request.args.copy()
         args['page_' + generalview_name] = page
-        return url_for(request.endpoint,**dict(new_args.items() + args.to_dict().items()))
+        return url_for(request.endpoint,**dict(list(new_args.items()) + list(args.to_dict().items())))
 
 
     @app_template_filter('link_page_size')
@@ -61,7 +61,7 @@
         new_args = request.view_args.copy()
         args = request.args.copy()
         args['psize_' + generalview_name] = page_size
-        return url_for(request.endpoint,**dict(new_args.items() + args.to_dict().items()))
+        return url_for(request.endpoint,**dict(list(new_args.items()) + list(args.to_dict().items())))
                 
 
     @app_template_filter('get_link_next')
--- flask_appbuilder/validators.py	(original)
+++ flask_appbuilder/validators.py	(refactored)
@@ -28,6 +28,6 @@
             # only test if Unique, if pk value is diferent on update.
             if not hasattr(form,'_id') or form._id != self.datamodel.get_keys(obj)[0]:
                 if self.message is None:
-                    self.message = field.gettext(u'Already exists.')
+                    self.message = field.gettext('Already exists.')
                 raise ValidationError(self.message)
         
--- flask_appbuilder/widgets.py	(original)
+++ flask_appbuilder/widgets.py	(refactored)
@@ -24,7 +24,7 @@
         jinja_env = ctx.app.jinja_env
         
         template = jinja_env.get_template(self.template)
-        args = dict(self.template_args.items() + kwargs.items())
+        args = dict(list(self.template_args.items()) + list(kwargs.items()))
         return template.render(args)
 
 
--- flask_appbuilder/charts/views.py	(original)
+++ flask_appbuilder/charts/views.py	(refactored)
@@ -120,7 +120,7 @@
             returns the keys from direct_columns
             Used in template, so that user can choose from options
         """
-        return self.direct_columns.keys()
+        return list(self.direct_columns.keys())
 
 
     def _get_chart_widget(self, filters=None,
@@ -264,7 +264,7 @@
         form = self.search_form.refresh()
         get_filter_args(self._filters)
 
-        direct_key = group_by or self.direct_columns.keys()[0]
+        direct_key = group_by or list(self.direct_columns.keys())[0]
         direct = self.direct_columns.get(direct_key)
 
         if self.base_order:
--- flask_appbuilder/models/group.py	(original)
+++ flask_appbuilder/models/group.py	(refactored)
@@ -1,4 +1,4 @@
-from __future__ import unicode_literals
+
 import calendar
 import logging
 from itertools import groupby
--- flask_appbuilder/security/manager.py	(original)
+++ flask_appbuilder/security/manager.py	(refactored)
@@ -110,7 +110,7 @@
         g.user = current_user
 
     def migrate_get_new_obj(self, old_obj, new_obj):
-        for col in old_obj.keys():
+        for col in list(old_obj.keys()):
             setattr(new_obj, col, getattr(old_obj, col))
         return new_obj
 
@@ -254,7 +254,7 @@
                     self._update_user_auth_stat(user, False)
                     return None
             except ldap.LDAPError as e:
-                if type(e.message) == dict and e.message.has_key('desc'):
+                if type(e.message) == dict and 'desc' in e.message:
                     log.error("LDAP Error {0}".format(e.message['desc']))
                     return None
                 else:
--- flask_appbuilder/security/models.py	(original)
+++ flask_appbuilder/security/models.py	(refactored)
@@ -137,7 +137,7 @@
         return as_unicode(self.id)
 
     def get_full_name(self):
-        return u'{0} {1}'.format(self.first_name, self.last_name)
+        return '{0} {1}'.format(self.first_name, self.last_name)
 
     def __repr__(self):
         return self.get_full_name()
--- flask_appbuilder/security/views.py	(original)
+++ flask_appbuilder/security/views.py	(refactored)
@@ -355,7 +355,7 @@
         )
 
     def oid_login_handler(self, f, oid):
-        if request.args.get('openid_complete') != u'yes':
+        if request.args.get('openid_complete') != 'yes':
             return f(False)
         consumer = Consumer(SessionWrapper(self), oid.store_factory())
         openid_response = consumer.complete(request.args.to_dict(),
@@ -363,9 +363,9 @@
         if openid_response.status == SUCCESS:
             return oid.after_login_func(OpenIDResponse(openid_response, []))
         elif openid_response.status == CANCEL:
-            oid.signal_error(u'The request was cancelled')
+            oid.signal_error('The request was cancelled')
             return redirect(oid.get_current_url())
-        oid.signal_error(u'OpenID authentication error')
+        oid.signal_error('OpenID authentication error')
         return redirect(oid.get_current_url())
 
     def after_login(self, resp):
